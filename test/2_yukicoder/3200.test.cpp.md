---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: ds/unionfind/unionfind.hpp
    title: ds/unionfind/unionfind.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://yukicoder.me/problems/no/3200
    links:
    - https://yukicoder.me/problems/no/3200
  bundledCode: "#line 1 \"test/2_yukicoder/3200.test.cpp\"\n#define PROBLEM \"https://yukicoder.me/problems/no/3200\"\
    \n#line 2 \"ds/unionfind/unionfind.hpp\"\n#include <algorithm>\n#include <numeric>\n\
    #include <vector>\n\nstruct UnionFind {\n        std::vector<int> parent, sz;\n\
    \        int num_comps;\n        UnionFind(int n = 0) { init(n); }\n        void\
    \ init(int n) {\n                parent.resize(n);\n                iota(parent.begin(),\
    \ parent.end(), 0);\n                sz.assign(n, 1);\n                num_comps\
    \ = n;\n        }\n        int find(int x) { return (x == parent[x] ? x : parent[x]\
    \ = find(parent[x])); }\n        bool same(int a, int b) { return find(a) == find(b);\
    \ }\n        int size(int x) { return sz[find(x)]; }\n        bool join(int a,\
    \ int b) {\n                a = find(a), b = find(b);\n                if (a !=\
    \ b) {\n                        if (sz[a] < sz[b]) std::swap(a, b);\n        \
    \                parent[b] = a;\n                        sz[a] += sz[b];\n   \
    \                     num_comps--;\n                        return true;\n   \
    \             }\n                return false;\n        }\n        std::vector<std::vector<int>>\
    \ groups() {\n                int n = parent.size();\n                std::vector<std::vector<int>>\
    \ res(n);\n                std::vector<int> group_size(n, 0);\n              \
    \  for (int i = 0; i < n; i++) {\n                        group_size[find(i)]++;\n\
    \                }\n                std::vector<std::vector<int>> result;\n  \
    \              std::vector<int> root_map(n, -1);\n                for (int i =\
    \ 0; i < n; i++) {\n                        int r = find(i);\n               \
    \         if (root_map[r] == -1) {\n                                root_map[r]\
    \ = result.size();\n                                result.push_back({});\n  \
    \                              result.back().reserve(group_size[r]);\n       \
    \                 }\n                        result[root_map[r]].push_back(i);\n\
    \                }\n                return result;\n        }\n};\n#line 3 \"\
    test/2_yukicoder/3200.test.cpp\"\n#include <bits/stdc++.h>\nusing namespace std;\n\
    \nvoid solve() {\n        int64_t N, M;\n        cin >> N >> M;\n        UnionFind\
    \ uf(N);\n        vector<array<int, 2>> Edges(M);\n        multiset<array<int,\
    \ 2>> st;\n        for (int i = 0; i < M; i++) {\n                cin >> Edges[i][0]\
    \ >> Edges[i][1];\n                Edges[i][0]--, Edges[i][1]--;\n           \
    \     if (Edges[i][0] > Edges[i][1]) {\n                        swap(Edges[i][0],\
    \ Edges[i][1]);\n                }\n                st.insert({Edges[i][0], Edges[i][1]});\n\
    \        }\n        int Q;\n        cin >> Q;\n        vector<int> query(Q);\n\
    \        for (int i = 0; i < Q; i++) {\n                int num_edge;\n      \
    \          cin >> num_edge;\n                num_edge--;\n                query[i]\
    \ = num_edge;\n                auto it = st.find(Edges[num_edge]);\n         \
    \       st.erase(it);\n        }\n        vector<int64_t> ans;\n        for (auto\
    \ &[u, v] : st) {\n                uf.join(u, v);\n        }\n        reverse(query.begin(),\
    \ query.end());\n        int64_t connected = 0, tot = N * (N - 1) / 2;\n     \
    \   auto group = uf.groups();\n        for (auto &root : group) {\n          \
    \      int64_t now = (int64_t)root.size();\n                connected += now *\
    \ (now - 1) / 2;\n        }\n        for (auto &num_edge : query) {\n        \
    \        ans.push_back(tot - connected);\n                int par1 = uf.find(Edges[num_edge][0]),\
    \ par2 = uf.find(Edges[num_edge][1]);\n                int64_t size1 = uf.sz[par1],\
    \ size2 = uf.sz[par2];\n                if (par1 != par2) {\n                \
    \        connected -= (size1 * (size1 - 1) / 2 + size2 * (size2 - 1) / 2);\n \
    \                       int64_t new_size = size1 + size2;\n                  \
    \      connected += new_size * (new_size - 1) / 2;\n                }\n      \
    \          uf.join(par1, par2);\n        }\n        reverse(ans.begin(), ans.end());\n\
    \        for (auto &x : ans) {\n                cout << x << '\\n';\n        }\n\
    }\n\nint main() {\n        ios::sync_with_stdio(false);\n        cin.tie(NULL);\n\
    \n        int t = 1;\n        // cin >> t;\n        while (t--) solve();\n\n \
    \       return 0;\n}\n"
  code: "#define PROBLEM \"https://yukicoder.me/problems/no/3200\"\n#include \"ds/unionfind/unionfind.hpp\"\
    \n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n        int64_t\
    \ N, M;\n        cin >> N >> M;\n        UnionFind uf(N);\n        vector<array<int,\
    \ 2>> Edges(M);\n        multiset<array<int, 2>> st;\n        for (int i = 0;\
    \ i < M; i++) {\n                cin >> Edges[i][0] >> Edges[i][1];\n        \
    \        Edges[i][0]--, Edges[i][1]--;\n                if (Edges[i][0] > Edges[i][1])\
    \ {\n                        swap(Edges[i][0], Edges[i][1]);\n               \
    \ }\n                st.insert({Edges[i][0], Edges[i][1]});\n        }\n     \
    \   int Q;\n        cin >> Q;\n        vector<int> query(Q);\n        for (int\
    \ i = 0; i < Q; i++) {\n                int num_edge;\n                cin >>\
    \ num_edge;\n                num_edge--;\n                query[i] = num_edge;\n\
    \                auto it = st.find(Edges[num_edge]);\n                st.erase(it);\n\
    \        }\n        vector<int64_t> ans;\n        for (auto &[u, v] : st) {\n\
    \                uf.join(u, v);\n        }\n        reverse(query.begin(), query.end());\n\
    \        int64_t connected = 0, tot = N * (N - 1) / 2;\n        auto group = uf.groups();\n\
    \        for (auto &root : group) {\n                int64_t now = (int64_t)root.size();\n\
    \                connected += now * (now - 1) / 2;\n        }\n        for (auto\
    \ &num_edge : query) {\n                ans.push_back(tot - connected);\n    \
    \            int par1 = uf.find(Edges[num_edge][0]), par2 = uf.find(Edges[num_edge][1]);\n\
    \                int64_t size1 = uf.sz[par1], size2 = uf.sz[par2];\n         \
    \       if (par1 != par2) {\n                        connected -= (size1 * (size1\
    \ - 1) / 2 + size2 * (size2 - 1) / 2);\n                        int64_t new_size\
    \ = size1 + size2;\n                        connected += new_size * (new_size\
    \ - 1) / 2;\n                }\n                uf.join(par1, par2);\n       \
    \ }\n        reverse(ans.begin(), ans.end());\n        for (auto &x : ans) {\n\
    \                cout << x << '\\n';\n        }\n}\n\nint main() {\n        ios::sync_with_stdio(false);\n\
    \        cin.tie(NULL);\n\n        int t = 1;\n        // cin >> t;\n        while\
    \ (t--) solve();\n\n        return 0;\n}\n"
  dependsOn:
  - ds/unionfind/unionfind.hpp
  isVerificationFile: true
  path: test/2_yukicoder/3200.test.cpp
  requiredBy: []
  timestamp: '2026-01-22 14:21:14+07:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/2_yukicoder/3200.test.cpp
layout: document
redirect_from:
- /verify/test/2_yukicoder/3200.test.cpp
- /verify/test/2_yukicoder/3200.test.cpp.html
title: test/2_yukicoder/3200.test.cpp
---
